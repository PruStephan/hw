\problemset{17 октября}

\begin{para}{wow}

Рассмотрим свободную грамматику

$E \rightarrow TE'$

$E' \rightarrow +TE'|\epsilon$

$T \rightarrow n | (E)$

Строим дерево, там есть множество нераскрытых нетерминалов.

Будем разбирать нерекурсивно, храня на стеке множество нераскрытых нетерминалов

Изначально на стеке лежит стартовый нетерминал

По какому правилу раскрыть? Смотрим на правые части, смотрим на first от них, выбираем то, правило, где наш первый символ строки входит в first.

\textbf{Алгоритм}

\textit{Стековая машина, управляющая таблица}

Таблица: строки - терминалы, нетерминалы, дно стека. Столбцы: терминалы, \$

\begin{itemize}

  \item (терминал, терминал) : проверяем равны ли, сдвигаем указатель, убираем символ со стека, иначе ошибка

  \item (нетерминал, символ) : смотрим на все правила, выбираем то, у которого символ входит в first, иначе если наш нетерминал раскрывается в эпсилон, то смотрим в follow.

  \item (терминал, конец строки) : ошибка
  
  \item дно стека : матчится только с концом строки

\end{itemize}

Грамматика регулярных выражений

$E \rightarrow E | A$

$E \rightarrow A$

$A \rightarrow AF$

$A \rightarrow F$

$F \rightarrow Z^*$

$F \rightarrow Z$

$Z \rightarrow c$

$Z \rightarrow (E)$

Правое ветвление

Когда есть два правила: $A \rightarrow \alpha \beta$

$A \rightarrow \alpha \gamma$

Избавление от правого ветвления: $A \rightarrow \alpha A'$

$A' \rightarrow \beta, A' \rightarrow \gamma$

Избавляемся от правого ветвления и от левой рекурсии

Посчитали first

\end{para}



\begin{para}{Восходящий разбор}

Возьмем грамматику арифметичексих выражаний. $E \rightarrow E + T, E \rightarrow T, T \rightarrow T * F, T \rightarrow F, F \rightarrow n, F \rightarrow (E)$

2 + 2 + 2 + 2. Для каждого символа понимаем, что что из него раскрылось, хуяк хуяк все получилосб

\begin{defe}{Перенос-свертка, shift-reduce}

Два стека: левый и правый. Слева будет разбор, справа будет слово.

Изначально справа лежит все выражение

Два возможных варианта: 

1) перенос одного символа правого стека в левую

2) Сворачиваем какую-то часть левого стека (сверху, разумеется)

\end{defe}


$\alpha \: \: | \: \: t$ - имеем такую строку

$handle = \gamma : \beta \gamma x = \alpha t$, при этом x - суффикс t

\textbf{LR(0) автомат.}

LR(0) ситуация(LR(0) item) - пара из правила и числа i, где $0 \leq i \leq |\alpha|$ - состояния автомата нашего

Переходы: $(A \rightarrow \alpha . B \beta) \rightarrow_B (A \rightarrow \alpha B .\beta)$

$(A \rightarrow \alpha . B \beta) \rightarrow_\epsilon (B \rightarrow .\gamma)$

 $(A \rightarrow \alpha . c \beta) \rightarrow_c (A \rightarrow \alpha c .\beta)$
 
Добавим нетерминал $E_0$ - триггер того, что мы успешно разобрали слово.

\textbf{Теорема}

Строка $\alpha$ допускается в состояние $(A \rightarrow \gamma .), \alpha = \beta \gamma, \exists t \in \Sigma^* : S \Rightarrow^* \beta A t \Rightarrow \beta \gamma t.$

Детерминизация.

Состояниями детерминированного автомата будут замкнутые множества LR(0) ситуаций.

Переходы

\begin{defe}{LR(0) грамматика}

Если в получившемся автомате нет состояний, которые одновременно содержат терминальную и нетерминальную ситуацию, или содержат два и более терминальных состояния

\end{defe}



\begin{defe}{LR(0) разбор}

\begin{enumerate}

  \item Построить автомат

  \item Детерминизировать

  \item Применяем перенос-свертка. Для принятия решения перенос-свертка применяем наш автомат на содержимое левого стека. Если мы оказываемся в состоянии, где лишь одна терминальная ситуация, применяем свертку, иначе перенос
  
\end{enumerate}

\end{defe}

\begin{defe}{SLR алгоритм}

\begin{enumerate}

  \item Строим автомат

  \item Детерминизируем

  \item Нужно принять решение.

  \item Пропускаем левый стек через автомат. Если там только нетерминальные, то делаем перенос.

Если есть терминальные. Если верхний символ правого стека принадлежит только одному из нетерминалов, которые мб получены сверткой, то делаем этот переход свертки

\end{enumerate}

\end{defe}

Коротко о FOLLOW

$A \rightarrow Bc, A \rightarrow xBb, A \rightarrow xC, B \rightarrow y, C \rightarrow yc$

xyc

\begin{defe}{LR(1) ситуация}

$\langle A \rightarrow \alpha, i, c \in \Sigma \cup \{ \epsilon \} \rangle$

\end{defe}

Переходы:

$(A \rightarrow \alpha . X \beta, c) \rightarrow_X (A \rightarrow \alpha X . \beta, c)$

$(A \rightarrow \alpha . B \beta, c) \rightarrow_\epsilon (B \rightarrow \gamma, d), d \in FIRST(\beta c)$

Делаем тут еще в $|FIRST(\beta c)|$ раз больше переходов


\begin{defe}{LR(1) разбор}

\begin{enumerate}

  \item Построить автомат

  \item Детерминизировать

  \item Если есть терминальная ситуация с некоторым символом предпросмотра, то делаем тот переход, в котором есть этот символ. Соответственно LR(1) грамматика - такая что в получившемся автомате нет конфликтов по свертке / свертке-переходу
  
\end{enumerate}

\end{defe}

\end{para}



\problemset{24 октября}

\begin{para}{KEK}

\begin{defe}{Атрибут-транслирующая грамматика}

Атрибуты - поля терминалов/нетерминалов

Транслирующие символы - нетерминалы, у которых единственное правило из этого нетерминала в эпсилон

\end{defe}

\textbf{Example}

$E \rightarrow E + T, E \rightarrow T, T \rightarrow T * F, T \rightarrow F, F \rightarrow n, F \rightarrow (E)$

$n, E, F, T : val$

$E \rightarrow E + T : \{ E_0.val = E_1.val + T_3.val \}$ - правила при раскрытии нетерминалов

$E \rightarrow T : E_0.val = T_2.val$ - правило копирования атрибутов

Рассмотрим версию без левой рекурсии

$E \rightarrow TE', E' \rightarrow +T, T \rightarrow FT', T' \rightarrow *F, E' \rightarrow \epsilon, T' \rightarrow \epsilon, F \rightarrow (n), F \rightarrow (E)$

E' acc, val

T acc, val - атрибуты

Синтезируемые и наследуемые атрибуты

Синтезируем - если зависит от детей данного нетерминала в дереве разбора, присваиваются в момент выхода из нетерминала в дереве разбора

Наследуем - если зависит от родителей или братьев, присваиваются в момент входы в нетерминал.

val - синт.

acc - наследуемый

Если рассматривать нетерминал как функцию, то синт. атрибуты - это возвращаемые значения, а наследуемые - это параметры

$E \rightarrow TE'$

$E' \rightarrow + T$, соответственно E' записывает себе в аккумулятор значение T - левого брата и считает val на поддереве

\end{para}

\begin{para}{хуярим нерекурсивные парсеры}

2 + 3 + 5

Будем хранить не синтезируемые атрибуты (как в рекурсии), а куда их надо отправить.

\end{para}






